# 数据科学原理与数据处理

## 1 Python行业分析

通过Stack OverFlow专业网站的大数据统计，Python相关技术模块访问量最大的簇是数据科学相关，然后才是后台开发。 



### 1.1 数据处理流程

![1573092293192](image/1573092293192.png)

### 1.2 数据科学岗位分析

![1573092468415](image/1573092468415.png)

## 2  数据分析好助手Jupyter notebook

Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。

### 2.1 Jupyter notebook的安装

##### ① 使用Anaconda安装

Anaconda一个封装多种工具，库的解释器，它已经自动为你安装了Jupter Notebook及其他工具。

##### ② 使用pip 安装

```undefined
pip3 install jupyter
```

**注意：在安装Jupyter Notebook过程中可能面临无法安装的问题（提示你要升级pip），输入下面的命令即可**

```undefined
pip install --upgrade pip
```

### 2.2 Jupyter notebook 基本使用

- 在命令行处，先cd到源代码文件目录 
- 然后输入 jupyter notebook 会自动打开一个jupyter web管理界面
- 点击右上角的new 下边的python3 创建一个脚本

![1573095091236](image/1573095091236.png)

- 点击 run进行运行会在运行完成后自动生成下一格
- 在notebook的脚本中 想将变量打印出来,不需要加print,直接输入变量名即可 

![1573521805960](image/1573521805960.png)

- 在notebook中的单元格内添加注释，直接#+注释就可以

![1573521785941](image/1573521785941.png)

- 标题  

![1573522157184](image/1573522157184.png)

- 快捷键 
  - shift+enter 直接运行并在下一行插入一个单元格 
  - ctrl+enter 直接运行但不插入单元格 
  - alt+enter 插入一个新的单元格

#### 2.3 Jupyter notebook 内置的魔法命令

- %run + 运行python文件路径

```python 
%run D:\hello.py
```

- %load 将文件中的内容读出来【load回来的代码不会自动执行 ,需要手动执行一遍 】

```python 
%load D:\hello.py
```

- %timeit 测试代码的执行时间 【%timeit后边只能跟一行代码】

```python
%timeit lis = [x for x in range(10000)]
```

- %%timeit 测试代码块的执行时间 

```python
%%timrit
lis = []
for i in range(10000):
    lis.append(1)
```

- %time 测试单次运行所需要的时间 【%time和%timeit都是测试时间，但是%time没有%timeit准确】

```python
%time lis = [x for x in range(10000)]
```

- %%time 测试代码块的执行时间

```python 
%%time
lis = []
for i in range(10000):
	lis.append(i)
```

- %%html 用于在notebook中显示页面代码

```python
%%html
<a href = 'www.baidu.com'>百度一下</a>
```

- %%js 用于在notebook中运行js文件的

```Python
%%html
<div class='mytest' style='color:red'>html content</div>

# 写在不同的单元格中
%%js
document.querySelector('.mytest').innerHTML='js content'
```

- %%writefile 将内容编写成文件

```Python
%%writefile  haha.py
    lis = [x for x in ramge(1000)]
```

## 3  数据科学模块NumPy

### 3.1 初级NumPy

#### 3.1.1 NumPy基本介绍

Numpy：提供了一个在Python中做科学计算的基础库，主要用于数值计算、多维数组（矩阵）的处理。本身是由C语言开发，是个很基础的扩展，Python其余的科学计算扩展大部分都是以此为基础。

NumPy是使用Python进行科学计算的基本软件包。它包含以下内容：

- 强大的N维数组对象
- 复杂的（广播）功能
- 集成C / C ++和Fortran代码的工具
- 有用的线性代数，傅立叶变换和随机数功能
- Nmupy本质就是ndarray 
- 多维矩阵 
  - 1维数组看做向量vector--点和直线 
  - 2维数组看做2维矩阵--表和平面 
  - 3维数组看做3维矩阵--空间

除了其明显的科学用途外，NumPy还可以用作通用数据的高效多维容器。可以定义任意数据类型。这使NumPy可以无缝，快速地与各种数据库集成。官方学习资料https://numpy.org/。

#### 3.1.2 NumPy的安装与导入

```
安装  pip install numpy
导入 import numpy as np
```

#### 3.1.3 NumPy中的数组创建

NumPy提供的最重要的数据结构是一个称为NumPy数组的强大对象。NumPy数组是通常的Python数组的扩展。NumPy数组配备了大量的函数和运算符，可以帮助我们快速编写各种类型计算的高性能代码。

```Python
import numpy


# 使用arange创建数组
arr = numpy.arange(0, 6, 2) # 一维数组
arr = numpy.arange(0, 6, 2).reshape(1, 3) # 二维数组
print(arr)

print('--------------------------------------------------------------------')
# 使用linspace创建数组——元素之间’等差‘
# 参数1 开始位置
# 参数2 结束位置
# 参数3 创建数组元素的个数
arr= numpy.linspace(0, 6, 7)
print(arr)

print('------------------------------------------------------------------')
# 使用logspace创建函数--元素之间’等比‘
# 参数1 开始位置 10^0
# 参数2 结束位置 10^2
# 参数3 创建数组元素的个数
arr = numpy.logspace(0, 2, 5)
print(arr)

print('------------------------------------------------------------------')
# ones --生成所有元素都为 1 的数组
arr = numpy.ones(shape = (2, 3))
print(arr)

print('------------------------------------------------------------------')
# zeros --生成所有元素都为 0 的数组
arr = numpy.zeros(shape=(2, 3))
print(arr)

print('------------------------------------------------------------------')
# eye--生成一种类似单位矩阵的数组
# 参数k 决定对角线的位置
# 参数k<0 ,对角线上移k个位置
# 参数k>0 ,对角线下移k个位置
# 参数k超出范围，是个（3,3）都为0的数组
arr = numpy.eye(3, 3, k = 0)
print(arr)

print('------------------------------------------------------------------')
# diag 生成一个对角矩阵数组，参数为对角线上的值
# k 上移，下移 和eye 一样
arr = numpy.diag([1, 3, 5, 7], k = 0)
arr1 = numpy.diag([[1, 3, 5, 7], [2, 4, 6, 8]])
print(arr, '\n', arr1)

print('------------------------------------------------------------------')
# 生成 (0,1)的随机数据的随机数组
arr = numpy.random.random(5)
arr1 = numpy.random.random((2, 3))
print(arr, '\n', arr1)

print('------------------------------------------------------------------')
# 生成随机数据的均匀分布的数组【需要数据量比较大】
arr = numpy.random.rand(5)
arr1 = numpy.random.rand(2, 3)
print(arr,'\n',arr1)

print('------------------------------------------------------------------')
# 生成一个符合正态分布的数组
# 参数为 元素个数 或者 行列数
arr = numpy.random.randn(2, 3)
print(arr)

print('------------------------------------------------------------------')
# 生成固定范围内的，固定形状的数组
#如果不传size ，那么生成一个随机整数
arr = numpy.random.randint(0, 5, size = [2, 3])
arr1 = numpy.random.randint(0, 5)
print(arr, '\n', arr1)

print('------------------------------------------------------------------')
# 获得一个均值为0 标准差为1 的矩阵数组
# 第一个参数是均值 第二个参数是标准差,第三个参数是元素的个数
arr = numpy.random.normal(0, 1, size = 1000000)
print(arr)
```

#### 3.1.4  NumPy的数组属性

```Python
import numpy
arr = numpy.array([[[1,2,3],[4,5,6],[7,8,9]],[[2,3,4],[9,8,7],[5,6,4]]])

print('数组的维度 : ',arr.ndim)
print('数组的形状 : ',arr.shape) # 2块 3行3列
print('数组的元素个数 : ',arr.size)
print('数组的数据类型 : ',arr.dtype)
print('数组的每个元素的大小 : ',arr.itemsize)
```

#### 3.1.5 NumPy数组操作

```Python
# Basic Operators
a = np.arange(25).reshape((5, 5))

b = np.array([10, 62, 1, 14, 2, 56, 79, 2, 1, 45,
              4, 92, 5, 55, 63, 43, 35, 6, 53, 24,
              56, 3, 56, 44, 78]).reshape((5,5))

print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a ** 2)
print(a < b) print(a > b)
# 这些操作符都是对数组进行逐元素运算。比如 (a, b, c) + (d, e, f) 的结果就是 (a+d, b+e, c+f)。它将分别对每一个元素进行配对，然后对它们进行运算。它返回的结果是一个数组。

print(a.dot(b))
# dot() 函数计算两个数组的点积。它返回的是一个标量（只有大小没有方向的一个值）而不是数组。
```

#### 3.1.6  数组的取值操作

```Python
# # 普通取值
# 一维数组

import numpy as np 
my_array = np.array([1, 2, 3, 4, 5]) 

print(my_array[0])  # 取一维数组的第一个
print(my_array[-1]) # 取一维数组的最后一个

# 二维数组
import numpy as np 
my_array = np.arange(15).reshape(3, 5)

print(my_array[0])  # 取二维数组的第一行
print(my_array[-1])  # 取二维数组的最后一行


# # 切片取值
# 一维数组
import numpy as np 
my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 

print(my_array[0: 5])
print(my_array[: 5])
print(my_array[0: 8: 2])
print(my_array[::-1])


# 二维数组
import numpy as np 
my_array = np.arange(15).reshape(3, 5)

print(my_array[0:5])
print(my_array[:5])
# 注:python生成的普通数组中, 切片切出来的值和原来的数据没有任何关系,一个改变 ,另 一个不发生改变
# 注:numpy生成的数组, 切片切出来的值和原来的数据有引用关系,一个改变 ,另一个也发 生改变
```

#### 3.1.7  ndarray 中的合并与分割

```Python
import numpy as np
# # 合并

# 一维数组的合并
arr_1 = np.array([1, 2, 3])
arr_2 = np.array([4, 5, 6])
arr = np.concatenate([arr1, arr2])

print(arr)

# 二维数组的合并
import numpy

arr_1 = numpy.arange(4).reshape((2, 2))
arr_2 = numpy.arange(4, 8).reshape((2, 2))

#数组组合
# 按行的方向【垂直】，进行拼接,参数是一个对象
new_arr = numpy.vstack((arr_1, arr_2))
print(new_arr)

# 按列的方向【水平】，进行拼接,参数是一个对象
new_arr = numpy.hstack((arr_1, arr_2))
print(new_arr)

# 和vstack一样
new_arr = numpy.concatenate((arr_1, arr_2), axis=0)
print(new_arr)

# 和hstack一样
new_arr = numpy.concatenate((arr_1, arr_2), axis=1)
print(new_arr)

# # 分割
# 一维数组
arr = np.arange(10)
print(arr.split(arr, 2))
print(arr.split(arr, 5))
# 第二个参数是指分割成几份 ,要传入正确的分割值,因为平均拆分，必须可以被数组位数整除

# 二维数组
arr = np.arange(16).reshape(4, 4)

# 在列的方向上进行分割数组
new_arr = numpy.hsplit(arr, 4)
new_arr1 = numpy.split(arr, 4, axis = 1)
print(new_arr)
print('-----------------------------------------------')
print(new_arr1)
print('-----------------------------------------------')

# 在行的方向上进行分割数组
new_arr = numpy.vsplit(arr, 4)
new_arr1 = numpy.split(arr, 4, axis = 0)
print(new_arr)
print('-----------------------------------------------')
print(new_arr1)
```

#### 3.1.8 NumPy中的矩阵创建

```Python
import numpy

# 创建矩阵，---【必须是二维的】

## mat
m11 = numpy.mat('1 2 3;4 5 6;7 8 9')
print(m11)
print('--------------------------mat1-----------------------')
#可以将列表转化为矩阵
m12 = numpy.mat([[1,2,3],[4,5,6],[7,8,9]])
print(m12)
print('--------------------------mat2-----------------------')
# 可以将数组转化为矩阵
m13 = numpy.mat(numpy.array([[1,2,3],[4,5,6],[7,8,9]]))
print(m13)
print('--------------------------mat3-----------------------')


## matrix
#m11 = numpy.matrix('1 2 3;4 5 6;7 8 9')
m11 = numpy.asmatrix('1 2 3;4 5 6;7 8 9')
print(m11)
print('--------------------------matrix1-----------------------')
#m12 = numpy.matrix([[1,2,3],[4,5,6],[7,8,9]])
m12 = numpy.asmatrix([[1,2,3],[4,5,6],[7,8,9]])
print(m12)
print('--------------------------matrix2-----------------------')
#m13 = numpy.matrix(numpy.array([[1,2,3],[4,5,6],[7,8,9]]))
m13 = numpy.asmatrix(numpy.array([[1,2,3],[4,5,6],[7,8,9]]))
print(m13)
print('--------------------------matrix3-----------------------')

# 推荐使用mat 或者 asmatrix【matrix，会复制一份，占用更多的内存空间】

## bmat 进行堆积组合矩阵

arr1 = list(numpy.arange(4).reshape(2,2))
arr2 = list(numpy.arange(4,8).reshape(2,2))
print(arr1,type(arr1))
new_arr = numpy.bmat([[arr1,arr2],[arr2,arr1]])
print(new_arr)
print('--------------------------bmat1-------------------------')
# 数组组合矩阵
arr1 = numpy.arange(4).reshape(2,2)
arr2 = numpy.arange(4,8).reshape(2,2)
print(arr1,type(arr1))

new_arr = numpy.bmat([[arr1,arr2],[arr2,arr1]])
print(new_arr)
print('--------------------------bmat2-------------------------')
#列表组合矩阵
arr1 = [[1,2,3],[4,5,6]]
arr2 = [[5,6,7],[7,8,9]]
print(arr1,type(arr1))

new_arr = numpy.bmat([[arr1,arr2],[arr2,arr1]])
print(new_arr)
print('--------------------------bmat3-------------------------')
# 矩阵组合矩阵
arr1 = numpy.mat('1 2;3 4')
arr2 = numpy.mat('5 6;7 8')
print(arr1,type(arr1))

new_arr = numpy.bmat([[arr1,arr2],[arr2,arr1]])
print(new_arr)
print('--------------------------bmat4-------------------------')
```

#### 3.1.9 NumPy数组中矩阵的运算

```Python
import numpy

jz1 = numpy.mat(numpy.arange(9).reshape(3,3))
jz2 = numpy.mat(numpy.arange(9,18).reshape(3,3))
jz3 = numpy.mat(numpy.arange(6).reshape(2,3))
jz4 = numpy.mat(numpy.arange(9,15).reshape(2,3))

#矩阵与数相乘
result = 3*jz1
print(result)
print('---------------------矩阵运算 1----------------------')

#矩阵与同形矩阵相加
result = jz1+jz2
print(result)
print('---------------------矩阵运算 2----------------------')

#矩阵与同形矩阵相减
result = jz1-jz2
print(result)
print('---------------------矩阵运算 3----------------------')

#矩阵与矩阵相乘【左矩阵列数 == 右矩阵行数(必须满足!)】
# result = jz3*jz1
# result = numpy.matmul(jz3,jz1) #在某些情况下 matmul 会比dot严格一点
result = numpy.dot(jz3,jz1) #
print(result)
print('---------------------矩阵运算 4----------------------')

#矩阵对应元素相乘 ---需要满足广播机制 ---数组的广播机制
result = numpy.multiply(jz1,jz2) #【必须同形】
print(result)
print('---------------------矩阵运算 5----------------------')

print(jz1,'\n',type(jz1))
print('矩阵的转置 : \n',jz1.T)
print('矩阵的逆矩阵 : \n',jz4.I) ## A * A.I = E
print('矩阵的共轭转置 : \n',jz1.H)
print('矩阵的视图 : \n',jz1.A)
print('矩阵的视图类型 : \n',type(jz1.A))

print(numpy.matmul(jz4,jz4.I)) # 等于单位矩阵
```

#### 3.1.10 Numpy的聚合操作

```Python
import numpy as np
# sum 求和 
arr = np.arange(16).reshape(4, 4)
print(np.sum(arr, axis = 0)) # axis=0 是竖着求和 axis=1 是横着求和

# min,max最小值和最大值
print(np.min(arr))  # 最小值
print(np.max(arr))  # 最大值

# prod 乘积
print(np.prod(arr))  # 乘积
print(np.prod(arr+1))  # 将全部的元素+1 然后每行进行相乘

# mean 平均值
print(np.mean(arr))  # 平均值
print(np.mean(arr, axis = 0))  # axis=0 求得的是每一列的平均值

# median() 中位数
print(np.median(arr, axis = 0))  # axis=0 求得的是每一列的中位数

# percentile 求矩阵的百分位数
print(np.mean(arr, q = 50))  # q=50 中位数  q=100 最大值

# var()计算矩阵的方差
print(np.var(arr))  # 方差

# std() 求矩阵的标准差
print(np.std(arr))  # 相当于方差开根
```

#### 3.1.11 NumPy的arg操作

```Python
import numpy as np

np.random.seed(40)
arr = np.random.random(50)

# 为了使代码在每次调用的时候能得到相同的值, 使用seed()来固定，值可随意
# argmin()获取最小值在矩阵中的索引
print(np.argmin(arr))

# argmax()获取最大值在矩阵中的索引
print(np.argmax(arr))

# argwhere() 在矩阵中寻找符合条件的数据 
print(np.argwhere(arr > 0.5))

# shuffle()打乱矩阵中的数据的顺序
print(np.random.shuffle(arr))

# argsort() 对矩阵的索引进行排序
print(np.argsort(arr))

# partition() 和 argpartition() 找到一个标准点 小于这个点的放在左 侧 大于这个点的放在右侧
print(np.partition(arr, 4)) # 参数一是要操作的矩阵数组,参数二是进行分割的标准点,返回值是数据
print(np.argpartition(arr, 4)) # 参数一是要操作的矩阵数组,参数二是进行分割的标准点,返回值是索引

# sort
arr = np.random.random(40，size = (5, 8))
print(np.sort(arr, axis = 0)) # sort默认对行进行排序,axis=0是对列进行排序.
```

#### 3.1.12 NumPy的比较运算与逻辑运算

```Python
import numpy as np


arr1 = np.arange(4).reshape(2, 2)
arr2 = np.array([1, 1, 3, 4]).reshape(2, 2)

#比较运算 ----返回同形的bool数组【同形数组 一一比较】
# <
result = arr1<arr2
print(result)
print('---------------比较运算 - 小于 - ---------------')
# <=
result = arr1<=arr2
print(result)
print('---------------比较运算 - 小于等于 - ---------------')
# >
result = arr1>arr2
print(result)
print('---------------比较运算 - 大于 - ---------------')
# >=
result = arr1>=arr2
print(result)
print('---------------比较运算 - 大于等于 - ---------------')
# =
result = arr1==arr2
print(result)
print('---------------比较运算 - 等于 - ---------------')
# ！=
result = arr1!=arr2
print(result)
print('---------------比较运算 - 不等于 - ---------------')

#逻辑运算

# any == or 【只要有一个条件满足T】
result = np.any(arr1 == arr2) #T
result1 = np.any(arr1 != arr2) #T
print(result, result1)
print('---------------逻辑运算 - any - ---------------')


# all == and 【所有条件满足为T】
result = np.all(arr1 == arr2) #F
result1 = np.all(arr1 != arr2) #F
print(result, result1)
print('---------------逻辑运算 - all - ---------------')

```

### 3.2 NumPy的进阶

#### 3.2.1 数组的展开

```Python
import numpy

arr = numpy.arange(16).reshape(4, 4)

# 进行数组展开

# ravel() --将高维度数组展开为一维，按行展开
print(arr.ravel())

# C按行存储 ，F按列存储
# flatten() --将高维度数组展开为一维，默认按行展开--C风格
print(arr.flatten())
print(arr.flatten(order= 'C'))

# 将高维度数组展开为一维，按列展开--F风格
print(arr.flatten(order= 'F'))
```

#### 3.2.2 数组的去重与重复

```Python
import numpy


arr1 = numpy.array([1, 2, 3, 4, 5, 3, 2 , 2, 2, 1, 1, 1, 1, 3])
arr = numpy.arange(4).reshape((2, 2))

# 对数组去重
# unique 去重+排序
res = numpy.unique(arr1)
print(res)

# 重复数据 -- tile作为整体进行重复N次

res = numpy.tile(arr, 2)
print(res)

# 按列进行重复n次
res = numpy.repeat(arr, 2, axis = 0)
# res = numpy.repeat(arr, 2, axis = 1)
print(res)
```

#### 3.2.3 数组的保存预读取

```Python
import numpy

arr1 = numpy.arange(16).reshape((4, 4))
arr2 = numpy.array([1, 2, 3, 4])


# save 以二进制形式保存数据，以 .npy为后缀的二进制文件
#参数1 保存文件的路径 + 文件名称，可以省略后缀
#参数2 要保存的数组
numpy.save('./arr1', arr1)

# 读取 -- 必须制定后缀名
data = numpy.load('./arr1.npy')
print(data)

# savez 来保存多个数组,以 .npz为后缀的二进制文件
#参数1 保存文件的路径 + 文件名称，可以省略后缀
#参数2 要保存的数组
numpy.savez('./arrz', arr1, arr2)

# 读取文件
data = numpy.load('./arrz.npz') #以键值对的形式存储
for tmp in data:
    print(tmp) #键
    print(data[tmp]) #键值

#文本形式的保存
# fmt 格式化  delimiter 字符间隔
numpy.savetxt('./arr.txt', arr1, fmt= '%d', delimiter= ' ')

# 读取文本形式的数组
data = numpy.loadtxt('./arr.txt', dtype= int, delimiter= ' ')
print(data)

# 可以读取结构化数组和缺失数据
data = numpy.genfromtxt('./arr.txt',dtype= int, delimiter= ' ', filling_values= 3)
print(data)
```

#### 3.2.4 广播机制

广播描述了在算术运算期间NumPy如何处理具有不同形状的数组。受某些约束条件的限制，较小的数组会在较大的数组中“广播”，以便它们具有兼容的形状。广播提供了一种向量化数组操作的方法，因此循环是在C而不是Python中进行的。

```
# 特性
# 让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐。
# 输出数组的shape是输入数组shape的各个轴上的最大值。
# 如果各个输入数组的对应轴【维度】的长度相同或者其长度为1时，这样的数组之间能够用来计算，否则出错。
# 当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值
```











## 4  统计与分析模块Pandas



## 5  数据可视化Matplotlib



## 6 项目实战 — 服务器日志分析